						Архитектурные ограничения

https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm
/*
REST означает репрезентативную передачу состояния, термин, введенный Роем Филдингом в 2000 году.
Это архитектурный стиль для разработки слабосвязанных приложений по сети, который часто используется при разработке веб-сервисов.

REST не навязывает никаких правил относительно того, как он должен быть реализован на более низком уровне,
он просто устанавливает высокоуровневые рекомендации по проектированию и оставляет нас думать о нашей собственной реализации.

*/
REST определяет 6 архитектурных ограничений, которые делают любой веб-сервис действительно RESTful API:

1.Единый интерфейс
2.Клиент-сервер
3.Без состояния
4.Кэшируемый
5.Многоуровневая система
6.Код по запросу (необязательно)

1. Единый интерфейс
Поскольку применяется само имя ограничения,вы ДОЛЖНЫ выбрать интерфейс API для ресурсов внутри системы, которые доступны для пользователей API и неукоснительно им следуют.
Ресурс в системе должен иметь только один логический URI, и это должно обеспечивать способ извлечения связанных или дополнительных данных.
Всегда лучше синонимизировать ресурс с веб-страницей .
Любой отдельный ресурс не должен быть слишком большим и содержать все и вся в своем представлении.
Когда это уместно, ресурс должен содержать ссылки (HATEOAS), указывающие на относительные URI для получения связанной информации.
Кроме того, представления ресурсов в системе должны соответствовать определенным рекомендациям,таким как соглашения об именах, форматы ссылок или формат данных (XML и/или JSON).
Все ресурсы должны быть доступны с помощью общего подхода, такого как HTTP GET, и аналогичным образом модифицироваться с использованием согласованного подхода.
Как только разработчик познакомится с одним из ваших API, он сможет использовать аналогичный подход для других API.

2. Клиент-сервер
Это ограничение по существу означает, что клиентские приложения и серверные приложения ДОЛЖНЫ иметь возможность развиваться отдельно, без какой-либо зависимости друг от друга.
Клиент должен знать только URI ресурсов, и все.
Сегодня это стандартная практика в веб-разработке, поэтому с вашей стороны не требуется ничего особенного. Будь проще.
Серверы и клиенты также могут быть заменены и разработаны независимо друг от друга, если интерфейс между ними не изменен.

3. Без гражданства
Рой Филдинг черпал вдохновение из HTTP, что и отражается в этом ограничении. Сделайте все взаимодействия клиент-сервер без сохранения состояния.
Сервер не будет хранить ничего о последнем HTTP-запросе, сделанном клиентом.
Он будет рассматривать каждый запрос как новый. Нет сеанса, нет истории.
Если клиентское приложение должно быть приложением с отслеживанием состояния для конечного пользователя, где пользователь входит в систему один раз и после этого выполняет другие авторизованные операции,
то каждый запрос от клиента должен содержать всю информацию, необходимую для обслуживания запроса, включая аутентификацию и детали авторизации.
Контекст клиента не должен храниться на сервере между запросами. Клиент отвечает за управление состоянием приложения.

4. Кэшируемый
В современном мире кэширование данных и ответов имеет первостепенное значение везде, где это применимо/возможно.
Веб-страница, которую вы читаете здесь, также является кешированной версией HTML-страницы. 
Кэширование повышает производительность на стороне клиента и расширяет масштабы масштабируемости сервера, поскольку нагрузка снижается.
В REST кэширование должно применяться к ресурсам, когда это применимо, и тогда эти ресурсы ДОЛЖНЫ объявить себя кэшируемыми.
Кэширование может быть реализовано на сервере или на стороне клиента.
Хорошо управляемое кэширование частично или полностью устраняет некоторые взаимодействия между клиентом и сервером, дополнительно повышая масштабируемость и производительность.

5. Многоуровневая система
REST позволяет вам использовать многоуровневую системную архитектуру, в которой вы развертываете API-интерфейсы на сервере A, 
храните данные на сервере B и аутентифицируете запросы, например, на сервере C. Клиент обычно не может сказать,
подключен ли он напрямую к конечному серверу или к посреднику по пути.


6. Код по запросу (необязательно)
Ну, это ограничение не является обязательным. Большую часть времени вы будете отправлять статические представления ресурсов в форме XML или JSON.
Но когда вам нужно, вы можете return executable codeподдерживать часть своего приложения, например, клиенты могут вызывать ваш API, чтобы получить код рендеринга виджета пользовательского интерфейса.
Это разрешено.
Все приведенные выше ограничения помогут вам создать настоящий RESTful API, и вы должны им следовать.
Тем не менее, время от времени вы можете обнаружить, что нарушаете одно или два ограничения. Не волнуйтесь; вы все еще делаете RESTful API, но не «настоящий RESTful».

Обратите внимание, что все вышеуказанные ограничения наиболее тесно связаны с WWW (интернетом).
Используя RESTful API, вы можете делать со своими веб-сервисами то же самое, что и с веб-страницами.